# coding=utf-8
# Copyright (C) 2024-2025 Golden_Hoe,HOE Software Team.
# AI Generate Information: Some GUI part generated by ChatGPT.
# AI生成提示：部分GUI实现使用ChatGPT/Google Gemini生成。

import sys
import os
import json
import psutil
import logging
from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
                             QPushButton, QComboBox, QFileDialog, QMessageBox,
                             QLabel, QLineEdit, QStackedWidget, QPlainTextEdit,
                             QScrollArea, QSizePolicy)
from PyQt5.QtCore import Qt, QThread, pyqtSignal, QProcess, QTimer, QCoreApplication
from PyQt5.QtGui import QFont, QTextCursor
from pywinstyles import apply_style
import urllib.request

# ==================== 配置日志 ====================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("launch.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# ==================== 全局常量和辅助函数 ====================
SETTINGS_FILE = "mcseasy_settings.meconf"
URL_LIST_FILE = "url_list.txt"
VERSION_LIST_FILE = "version_list.txt"
BAT_FILE_NAME = 'StartServer.bat'
EULA_FILE_NAME = 'eula.txt'
SERVER_PROPERTIES_FILE = 'server.properties'

def load_list_file(filename: str) -> list:
    """从文本文件加载Python列表"""
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            content = f.read().strip()
        return eval(content)
    except (FileNotFoundError, IOError) as e:
        logger.error(f'加载文件列表失败，文件不存在或读取错误: {e}')
        return []
    except Exception as e:
        logger.error(f'加载文件列表错误: {e}')
        return []

def check_hardware():
    """检测硬件信息并弹出非阻塞式警告"""
    warn_messages = []

    # 检查CPU核心数量
    cpu_cores = psutil.cpu_count(logical=False)
    logger.info(f"CPU物理核心数量: {cpu_cores}")
    if cpu_cores < 2:
        warn_messages.append("CPU物理核心数少于2，可能会导致服务器性能偏低。")

    # 检查内存
    memory = psutil.virtual_memory()
    total_memory_mb = memory.total / 1024**2
    logger.info(f"计算机总内存: {total_memory_mb:.2f} MB")
    if total_memory_mb < 2048:
        warn_messages.append("已安装的运行内存少于2048M，可能会导致服务器性能偏低。")

    # 检查磁盘空间
    current_file_path = os.path.abspath(__file__)
    disk_root = os.path.splitdrive(current_file_path)[0] + os.sep
    try:
        disk_usage = psutil.disk_usage(disk_root)
        disk_free_gb = disk_usage.free / 1024**3
        logger.info(f"当前磁盘可用容量: {disk_free_gb:.2f} GB")
        if disk_free_gb < 8:
            warn_messages.append("磁盘可用空间不足8GB，可能会导致服务器文件无法存放。")
    except Exception as e:
        logger.error(f"无法检查磁盘空间: {e}")

    if warn_messages:
        logger.warning(f"硬件检查结束，共发现{len(warn_messages)}个性能问题。")
        full_message = "硬件检测发现了以下性能问题：\n\n" + "\n".join([f"- {msg}" for msg in warn_messages])
        # 使用 QTimer 延迟显示 QMessageBox，确保主窗口已经创建
        QTimer.singleShot(100, lambda: QMessageBox.warning(
            None, "警告", full_message, QMessageBox.Ok))
    else:
        logger.info('硬件检查结束，没有发现问题。')

# ==================== 下载线程类 ====================
class DownloadThread(QThread):
    progress_updated = pyqtSignal(int)
    download_finished = pyqtSignal(bool, str)

    def __init__(self, url, save_path):
        super().__init__()
        self.url = url
        self.save_path = save_path
        self._is_stopped = False

    def stop(self):
        self._is_stopped = True

    def run(self):
        try:
            with urllib.request.urlopen(self.url) as response:
                total_size = int(response.headers.get('Content-Length', 0))
                downloaded = 0
                chunk_size = 8192
                filename = os.path.join(self.save_path, self.url.split('/')[-1])
                with open(filename, 'wb') as f:
                    while not self._is_stopped:
                        chunk = response.read(chunk_size)
                        if not chunk:
                            break
                        f.write(chunk)
                        downloaded += len(chunk)
                        if total_size > 0:
                            self.progress_updated.emit(int((downloaded / total_size) * 100))
                        QCoreApplication.processEvents() # 确保UI响应
            if self._is_stopped:
                self.download_finished.emit(False, "下载已取消")
            else:
                self.download_finished.emit(True, filename)
        except Exception as e:
            self.download_finished.emit(False, str(e))

# ==================== 主窗口类 ====================
class ServerDeployWindow(QMainWindow):
    log_signal = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self.setWindowTitle("简单 Minecraft 服务器部署工具(MCSEasy) Version-1.2.0.0-Beta2")
        self.setGeometry(100, 100, 1000, 500)
        self.download_thread = None
        self.server_process = None
        self.server_running = False
        self.has_unsaved_changes = False
        self.config_controls = {}
        self.original_config = {}

        self.url_list = load_list_file(URL_LIST_FILE)
        self.version_list = load_list_file(VERSION_LIST_FILE)
        
        self._setup_ui()
        self._apply_styles()
        self._connect_signals()
        self._load_settings()

    def _setup_ui(self):
        """设置主界面布局和控件"""
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QHBoxLayout(central_widget)

        # 左侧操作区域
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        
        left_layout.addWidget(QLabel("选择操作模式:"))
        self.mode_combo = QComboBox()
        self.mode_combo.addItems(['启动服务器', '下载服务端', '配置内存', '修改服务器配置'])
        left_layout.addWidget(self.mode_combo)

        self.stacked_widget = QStackedWidget()
        self._create_start_page()
        self._create_download_page()
        self._create_memory_page()
        self._create_config_page()
        left_layout.addWidget(self.stacked_widget)
        main_layout.addWidget(left_widget, stretch=2)

        # 右侧日志区域
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        self.create_status_label(right_layout)
        
        self.log_widget = QPlainTextEdit()
        self.log_widget.setReadOnly(True)
        self.log_widget.setFont(QFont("Microsoft YaHei", 9, QFont.Bold))
        right_layout.addWidget(self.log_widget)
        
        self.command_input = QLineEdit()
        self.command_input.setPlaceholderText("输入服务器指令（按回车发送）")
        right_layout.addWidget(self.command_input)
        
        main_layout.addWidget(right_widget, stretch=3)
        self.right_widget = right_widget
    
    def _apply_styles(self):
        """应用并配置窗口样式"""
        apply_style(self, "normal")
        self.setStyleSheet("""
            QWidget {
                color: black;
                font-family: 'Microsoft YaHei';
            }
            QComboBox, QLineEdit {
                background-color: #FFFFFF;
                border: 1px solid #0078D4;
                padding: 5px;
                border-radius: 5px;
            }
            QPushButton {
                background-color: #FFFFFF;
                border: 1px solid #0078D4;
                padding: 5px;
                border-radius: 5px;
            }
            QPushButton:hover {
                background-color: #F5F5F5;
            }
            QPushButton:pressed {
                background-color: #E0E0E0;
            }
            QComboBox::drop-down {
                border: none;
            }
            QPlainTextEdit {
                background-color: #1E1E1E;
                color: #FFFFFF;
                border: 1px solid #333333;
                border-radius: 8px;
                font-family: 'Microsoft Yahei';
                font-weight: bold;
            }
        """)

    def _connect_signals(self):
        """连接所有信号到槽"""
        self.mode_combo.currentIndexChanged.connect(self._switch_mode_page)
        self.log_signal.connect(self._update_log)
        self.command_input.returnPressed.connect(self._send_command)

    def _create_start_page(self):
        """创建“启动服务器”页面"""
        self.start_page = QWidget()
        layout = QVBoxLayout(self.start_page)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(5)

        path_group = QWidget()
        path_layout = QVBoxLayout(path_group)
        path_layout.addWidget(QLabel("服务器路径:"))
        self.path_label_start = QLabel("未选择路径")
        self.path_label_start.setWordWrap(True)
        path_layout.addWidget(self.path_label_start)
        self.path_btn_start = QPushButton("选择服务器路径")
        self.path_btn_start.clicked.connect(self._select_directory)
        path_layout.addWidget(self.path_btn_start)
        layout.addWidget(path_group)

        layout.addStretch(1)

        btn_group = QWidget()
        btn_layout = QVBoxLayout(btn_group)
        btn_layout.setSpacing(5)
        self.execute_btn_start = QPushButton("启动服务器")
        self.execute_btn_start.clicked.connect(lambda: self._execute_action('启动服务器'))
        self.stop_btn = QPushButton("停止服务器")
        self.stop_btn.hide()
        self.stop_btn.clicked.connect(self._stop_server)
        btn_layout.addWidget(self.execute_btn_start)
        btn_layout.addWidget(self.stop_btn)
        layout.addWidget(btn_group)
        self.stacked_widget.addWidget(self.start_page)

    def _create_download_page(self):
        """创建“下载服务端”页面"""
        page = QWidget()
        layout = QVBoxLayout(page)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(5)

        version_group = QWidget()
        version_layout = QVBoxLayout(version_group)
        version_layout.addWidget(QLabel("选择服务端版本:"))
        self.version_combo = QComboBox()
        self.version_combo.addItems(self.version_list)
        version_layout.addWidget(self.version_combo)
        layout.addWidget(version_group)

        path_group = QWidget()
        path_layout = QVBoxLayout(path_group)
        path_layout.addWidget(QLabel("安装路径:"))
        self.path_label_download = QLabel("未选择路径")
        self.path_label_download.setWordWrap(True)
        path_layout.addWidget(self.path_label_download)
        self.path_btn_download = QPushButton("选择安装路径")
        self.path_btn_download.clicked.connect(self._select_directory)
        path_layout.addWidget(self.path_btn_download)
        layout.addWidget(path_group)

        layout.addStretch(1)

        self.execute_btn_download = QPushButton("开始下载")
        self.execute_btn_download.clicked.connect(lambda: self._execute_action('下载服务端'))
        layout.addWidget(self.execute_btn_download)
        self.stacked_widget.addWidget(page)

    def _create_memory_page(self):
        """创建“配置内存”页面"""
        page = QWidget()
        layout = QVBoxLayout(page)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(5)

        mem_group = QWidget()
        mem_layout = QVBoxLayout(mem_group)
        mem_layout.addWidget(QLabel("最小内存(GB):"))
        self.mem_min = QLineEdit()
        mem_layout.addWidget(self.mem_min)
        mem_layout.addWidget(QLabel("最大内存(GB):"))
        self.mem_max = QLineEdit()
        mem_layout.addWidget(self.mem_max)
        layout.addWidget(mem_group)

        path_group = QWidget()
        path_layout = QVBoxLayout(path_group)
        path_layout.addWidget(QLabel("服务器路径:"))
        self.path_label_memory = QLabel("未选择路径")
        self.path_label_memory.setWordWrap(True)
        path_layout.addWidget(self.path_label_memory)
        self.path_btn_memory = QPushButton("选择服务器路径")
        self.path_btn_memory.clicked.connect(self._select_directory)
        path_layout.addWidget(self.path_btn_memory)
        layout.addWidget(path_group)

        layout.addStretch(1)

        self.execute_btn_memory = QPushButton("保存配置")
        self.execute_btn_memory.clicked.connect(lambda: self._execute_action('配置内存'))
        layout.addWidget(self.execute_btn_memory)
        self.stacked_widget.addWidget(page)

    def _create_config_page(self):
        """创建“修改服务器配置”页面"""
        self.config_page = QWidget()
        layout = QVBoxLayout(self.config_page)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(5)

        back_btn = QPushButton('返回')
        back_btn.clicked.connect(self._check_unsaved_changes)
        layout.addWidget(back_btn, alignment=Qt.AlignLeft)
        
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_content = QWidget()
        self.config_layout = QVBoxLayout(scroll_content)
        scroll_area.setWidget(scroll_content)
        layout.addWidget(scroll_area)

        btn_group = QWidget()
        btn_layout = QHBoxLayout(btn_group)
        self.save_btn = QPushButton("保存并退出")
        self.save_btn.clicked.connect(self._save_server_config)
        self.revert_btn = QPushButton("撤销全部更改")
        self.revert_btn.clicked.connect(self._load_server_config)
        btn_layout.addWidget(self.revert_btn)
        btn_layout.addWidget(self.save_btn)
        layout.addWidget(btn_group)
        self.stacked_widget.addWidget(self.config_page)

    def _load_settings(self):
        """加载保存的配置"""
        if os.path.exists(SETTINGS_FILE):
            try:
                with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
                    settings = json.load(f)
                    self.path_label_start.setText(settings.get("start_path", ""))
                    self.path_label_download.setText(settings.get("download_path", ""))
                    self.path_label_memory.setText(settings.get("memory_path", ""))
                    self.mem_min.setText(settings.get("min_mem", ""))
                    self.mem_max.setText(settings.get("max_mem", ""))
                self.log_signal.emit("[MCSEasy-INFO] 已加载保存的配置")
            except Exception as e:
                self.log_signal.emit(f"[MCSEasy-ERROR] 配置加载失败: {e}")
                logger.error(f'配置加载失败: {e}')

    def _save_settings(self):
        """保存当前配置到文件"""
        settings = {
            "start_path": self.path_label_start.text(),
            "download_path": self.path_label_download.text(),
            "memory_path": self.path_label_memory.text(),
            "min_mem": self.mem_min.text(),
            "max_mem": self.mem_max.text()
        }
        try:
            with open(SETTINGS_FILE, 'w', encoding='utf-8') as f:
                json.dump(settings, f, indent=2)
            self.log_signal.emit("[MCSEasy-INFO] 配置已保存")
        except Exception as e:
            self.log_signal.emit(f"[MCSEasy-ERROR] 配置保存失败: {e}")
            logger.error(f'配置保存失败: {e}')

    def _switch_mode_page(self, index):
        """切换模式页面"""
        self.stacked_widget.setCurrentIndex(index)
        self.right_widget.setVisible(index in [0, 1, 2])

    def _select_directory(self):
        """选择路径并更新对应页面的标签"""
        path = QFileDialog.getExistingDirectory(self, "选择路径")
        if not path:
            return
        
        mode = self.mode_combo.currentText()
        if mode == '启动服务器' or mode == '修改服务器配置':
            self.path_label_start.setText(path)
        elif mode == '下载服务端':
            self.path_label_download.setText(path)
        elif mode == '配置内存':
            self.path_label_memory.setText(path)
        self._save_settings()

    def _execute_action(self, mode):
        """执行操作并记录日志"""
        try:
            if mode == '启动服务器':
                path = self.path_label_start.text()
                self._launch_server(path)
            elif mode == '下载服务端':
                path = self.path_label_download.text()
                version = self.version_combo.currentText()
                self._download_server(path, version)
            elif mode == '配置内存':
                path = self.path_label_memory.text()
                self._configure_memory(path)
            self.log_signal.emit(f"[MCSEasy-INFO] {mode} 操作已执行")
        except Exception as e:
            self.log_signal.emit(f"[MCSEasy-ERROR] {e}")
            QMessageBox.critical(self, "错误", f"操作失败: {e}")
            logger.error(f'操作失败: {e}')

    def _update_log(self, message):
        """更新日志内容"""
        cursor = self.log_widget.textCursor()
        cursor.movePosition(QTextCursor.End)
        cursor.insertText(f"{message}\n")
        self.log_widget.setTextCursor(cursor)
        self.log_widget.ensureCursorVisible()

    def _launch_server(self, path: str):
        """启动服务器"""
        if not path or not os.path.exists(os.path.join(path, BAT_FILE_NAME)):
            raise ValueError("无效的服务器路径，缺少StartServer.bat文件。")

        self._modify_eula(path)
        
        try:
            os.chdir(path)
            self.server_process = QProcess()
            self.server_process.setProcessChannelMode(QProcess.MergedChannels)
            self.server_process.readyReadStandardOutput.connect(self._handle_process_output)
            self.server_process.finished.connect(self._on_server_stopped)
            
            self.execute_btn_start.hide()
            self.stop_btn.show()
            self.server_process.start("cmd.exe", ["/c", BAT_FILE_NAME])
            self._update_server_status(True)
            self.log_signal.emit("[MCSEasy-INFO] 服务器已启动")
        except Exception as e:
            self.log_signal.emit(f"[MCSEasy-ERROR] 启动失败: {e}")
            logger.error(f'启动服务器失败: {e}')
    
    def _on_server_stopped(self):
        """服务器停止时的处理"""
        self.execute_btn_start.show()
        self.stop_btn.hide()
        self._update_server_status(False)
        self.log_signal.emit("[MCSEasy-INFO] 服务器已停止")
        logger.info('服务器已停止')
    
    def _stop_server(self):
        """停止服务器"""
        if self.server_process and self.server_process.state() == QProcess.Running:
            self.server_process.write("stop\n".encode())
            QTimer.singleShot(20000, self._force_kill_server)
        else:
            QMessageBox.warning(self, "警告", "服务器未在运行。")

    def _force_kill_server(self):
        """强制终止服务器进程"""
        if self.server_process and self.server_process.state() == QProcess.Running:
            self.server_process.kill()
            self.log_signal.emit("[MCSEasy-WARN] 已强制终止服务器进程")
            logger.warning('服务器进程被强制停止')

    def _send_command(self):
        """发送指令到服务器"""
        command = self.command_input.text()
        if command and self.server_process and self.server_process.state() == QProcess.Running:
            self.server_process.write(f"{command}\n".encode())
            self.command_input.clear()
        else:
            QMessageBox.warning(self, "警告", "服务器未在运行，无法发送指令。")

    def _handle_process_output(self):
        """处理进程输出"""
        if self.server_process:
            output = self.server_process.readAllStandardOutput().data().decode("gbk", errors='replace')
            self.log_signal.emit(output.strip())

    def _download_server(self, path: str, version: str):
        """下载服务器文件"""
        if not path:
            raise ValueError("请先选择安装路径")
        
        try:
            index = self.version_list.index(version)
            url = self.url_list[index]
        except ValueError:
            raise ValueError("无效的版本选择")

        try:
            urllib.request.urlopen('http://connectivitycheck.gstatic.com/generate_204', timeout=5)
        except Exception:
            raise ConnectionError("网络连接异常，请检查您的网络设置。")

        self.download_thread = DownloadThread(url, path)
        self.download_thread.progress_updated.connect(lambda p: self.execute_btn_download.setText(f"下载中... {p}%"))
        self.download_thread.download_finished.connect(self._on_download_finished)
        self.execute_btn_download.setEnabled(False)
        self.download_thread.start()
        
    def _on_download_finished(self, success: bool, message: str):
        """下载完成时的处理"""
        self.execute_btn_download.setEnabled(True)
        self.execute_btn_download.setText("开始下载")
        if success:
            QMessageBox.information(self, "完成", f"服务端已保存至:\n{message}")
            logger.info(f'下载完毕，服务器文件保存至: {message}')
        else:
            QMessageBox.critical(self, "错误", f"下载失败: {message}")
            logger.error(f'下载失败: {message}')
            
    def _configure_memory(self, path: str):
        """配置内存并写入bat文件"""
        min_mem_str = self.mem_min.text()
        max_mem_str = self.mem_max.text()
        
        if not min_mem_str.isdigit() or not max_mem_str.isdigit():
            raise ValueError("请输入有效的数字")

        min_mem = int(min_mem_str)
        max_mem = int(max_mem_str)
        
        if max_mem <= min_mem:
            raise ValueError("最大内存必须大于最小内存")

        bat_path = os.path.join(path, BAT_FILE_NAME)
        try:
            with open(bat_path, 'w', encoding='utf-8') as f:
                f.write(f'java -Xmx{max_mem}G -Xms{min_mem}G -jar server.jar --nogui')
            self._save_settings()
            QMessageBox.information(self, "成功", "内存配置已更新并保存到StartServer.bat文件。")
        except Exception as e:
            raise IOError(f"写入配置文件失败: {e}")

    def _modify_eula(self, path: str):
        """修改eula.txt以同意协议"""
        eula_path = os.path.join(path, EULA_FILE_NAME)
        if os.path.exists(eula_path):
            try:
                with open(eula_path, "r", encoding='utf-8') as f:
                    content = f.read()
                if "eula=false" in content.lower():
                    with open(eula_path, 'w', encoding='utf-8') as f:
                        f.write(content.replace("eula=false","eula=true"))
                    self.log_signal.emit("[MCSEasy-INFO] 已自动同意EULA协议")
                    logger.info('自动同意EULA成功')
            except Exception as e:
                logger.error(f'自动同意EULA失败: {e}')

    def _load_server_config(self):
        """加载服务器配置并生成UI控件"""
        path = self.path_label_start.text()
        if not path or not os.path.exists(path):
            QMessageBox.warning(self, "警告", "请先选择有效的服务器路径")
            return

        # 清理旧控件
        for widget in reversed(range(self.config_layout.count())):
            item = self.config_layout.takeAt(widget)
            if item.widget():
                item.widget().deleteLater()
        
        prop_path = os.path.join(path, SERVER_PROPERTIES_FILE)
        self.original_config = {}

        if os.path.exists(prop_path):
            try:
                with open(prop_path, 'r', encoding='gbk', errors='ignore') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            key_val = line.split('=', 1)
                            if len(key_val) == 2:
                                self.original_config[key_val[0]] = key_val[1]
            except Exception as e:
                logger.error(f'配置文件读取失败: {e}')
                QMessageBox.critical(self, "错误", f"读取 server.properties 失败: {e}")
                return

        self.config_controls = {}
        for key, value in self.original_config.items():
            widget = QWidget()
            layout = QHBoxLayout(widget)
            layout.setContentsMargins(0, 0, 0, 0)
            
            label = QLabel(f"{key}:")
            label.setFixedWidth(200) # 固定标签宽度以对齐
            layout.addWidget(label, stretch=1)
            
            if value.lower() in ['true', 'false']:
                combo = QComboBox()
                combo.addItems(['true', 'false'])
                combo.setCurrentText(value)
                combo.textActivated.connect(self._on_config_changed)
                self.config_controls[key] = combo
                layout.addWidget(combo, stretch=2)
            else:
                edit = QLineEdit()
                edit.setText(value)
                edit.textChanged.connect(self._on_config_changed)
                self.config_controls[key] = edit
                layout.addWidget(edit, stretch=2)
                
            self.config_layout.addWidget(widget)

        self.config_layout.addStretch(1) # 添加拉伸空间
        self.stacked_widget.setCurrentIndex(3)
        self.has_unsaved_changes = False

    def _on_config_changed(self, text=None):
        """检查是否有未保存的更改"""
        self.has_unsaved_changes = any(
            (c.currentText() if isinstance(c, QComboBox) else c.text()) != self.original_config.get(k, "")
            for k, c in self.config_controls.items()
        )

    def _save_server_config(self):
        """保存服务器配置"""
        path = self.path_label_start.text()
        if not path:
            return
        
        prop_path = os.path.join(path, SERVER_PROPERTIES_FILE)
        
        try:
            with open(prop_path, 'w', encoding='utf-8') as f:
                for key, control in self.config_controls.items():
                    value = control.currentText() if isinstance(control, QComboBox) else control.text()
                    f.write(f"{key}={value}\n")
            
            self.stacked_widget.setCurrentIndex(0)
            self.log_signal.emit("[MCSEasy-INFO] 服务器配置已更新")
            logger.info('服务器配置更新成功')
            self.has_unsaved_changes = False
        except Exception as e:
            QMessageBox.critical(self, "错误", f"保存配置失败: {e}")
            logger.error(f'保存配置失败: {e}')

    def _check_unsaved_changes(self):
        """检查未保存的更改"""
        if self.has_unsaved_changes:
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle("未保存的更改")
            msg_box.setText("您有未保存的更改，是否要保存？")
            msg_box.setStandardButtons(QMessageBox.Save | QMessageBox.Discard | QMessageBox.Cancel)
            msg_box.setDefaultButton(QMessageBox.Save)
            ret = msg_box.exec_()
            
            if ret == QMessageBox.Save:
                self._save_server_config()
            elif ret == QMessageBox.Discard:
                self.stacked_widget.setCurrentIndex(0)
            else:
                return # Cancel, do nothing
        else:
            self.stacked_widget.setCurrentIndex(0)
            
    def create_status_label(self, layout):
        """创建状态标签"""
        self.status_label = QLabel("已停止")
        self.status_label.setAlignment(Qt.AlignCenter)  # 居中对齐
        self.status_label.setFixedWidth(100) # 根据需要设置固定宽度
        self.status_label.setStyleSheet("background-color: #EB5757; color: white; padding: 4px; border-radius: 6px;")
    
        log_header_layout = QHBoxLayout()
        log_header_label = QLabel("服务器日志输出:")
        log_header_layout.addWidget(log_header_label)
        log_header_layout.addStretch()
        log_header_layout.addWidget(self.status_label)

        container = QWidget()
        container.setLayout(log_header_layout)
        layout.addWidget(container)
    
    def _update_server_status(self, is_running: bool):
        """更新服务器状态显示"""
        self.server_running = is_running
        if is_running:
            self.status_label.setText("运行中")
            self.status_label.setStyleSheet("background-color: #6FCF97; color: white; padding: 4px; border-radius: 6px;")
        else:
            self.status_label.setText("已停止")
            self.status_label.setStyleSheet("background-color: #EB5757; color: white; padding: 4px; border-radius: 6px;")

if __name__ == "__main__":
    app = QApplication(sys.argv)
    app_font = QFont("Microsoft YaHei")
    app.setFont(app_font)
    window = ServerDeployWindow()
    window.show()
    check_hardware()  # 在主窗口显示后调用
    sys.exit(app.exec_())